var documenterSearchIndex = {"docs":
[{"location":"howto/#How-To","page":"How To","title":"How-To","text":"","category":"section"},{"location":"howto/#Serve-a-REPL-from-a-remote-server","page":"How To","title":"Serve a REPL from a remote server","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"Run an ssh server on your.example.host and perform the usual ssh setup. (For example, add your public key to ~/.ssh/authorized_keys on the server.)\nYour Julia server should call serve_repl(). Use @async serve_repl() if you'd like to run other server tasks concurrently.","category":"page"},{"location":"howto/#Connect-to-a-REPL-on-a-remote-server","page":"How To","title":"Connect to a REPL on a remote server","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"Set up passwordless ssh to your server. Usually this means you have ssh-agent running with your private key loaded. If you've got some particular ssh options needed for the server, you'll find it convenient to set these up in the OpenSSH config file (~/.ssh/config on unix). For example,\nHost your.example.host\n   User ubuntu\n   IdentityFile ~/.ssh/some_identity\nStart up Julia and run the code\nusing RemoteREPL; connect_repl(\"your.example.host\");\nAlternatively use the shell wrapper script RemoteREPL/bin/julia-r:\njulia-r your.example.host","category":"page"},{"location":"howto/#Plot-variables-from-the-server","page":"How To","title":"Plot variables from the server","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"The @remote macro can be used to get variables from the server and plot them on the client with a single line of code. For example:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia@your.host> x = 1:42; y = x.^2;\n\njulia> plot(@remote((x,y))...)","category":"page"},{"location":"howto/#Use-stdout-with-println/dump,-etc","page":"How To","title":"Use stdout with println/dump, etc","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"Lots of functions such as print write to the global stdout variable, but RemoteREPL doesn't capture this.","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"There's two ways to get a similar effect in RemoteREPL, both of which rely on passing an IO object explicitly to println/dump/etc.","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"One way is to use @remote(stdout) which creates a proxy of the client's stdout stream on the server which you can write to:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia@localhost> dump(@remote(stdout), :(a + b))\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Symbol a\n    3: Symbol b","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"Another way is to use sprint to create the IO object and wrap the returned value in a Text object for display:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia@localhost> Text(sprint(dump, :(a+b)))\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Symbol a\n    3: Symbol b","category":"page"},{"location":"howto/#Include-a-remote-file","page":"How To","title":"Include a remote file","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"To include a Julia source file from the client into the current module on the remote side, use the %include REPL magic:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia@localhost> %include some/file.jl","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"%include has tab completion for local paths on the client.","category":"page"},{"location":"howto/#Evaluate-commands-in-another-module","page":"How To","title":"Evaluate commands in another module","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"If your server process has state in another module, you can tell RemoteREPL to evaluate all commands in that module. For example:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia@localhost> module SomeMod\n                    a_variable = 1\n                 end\nMain.SomeMod\n\njulia@localhost> a_variable\nERROR: UndefVarError: a_variable not defined\n[...]\n\njulia@localhost> %module SomeMod\nEvaluating commands in module Main.SomeMod\n\njulia@localhost> a_variable\n1","category":"page"},{"location":"howto/#Use-common-session-among-different-clients","page":"How To","title":"Use common session among different clients","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"A session, as implemented in ServerSideSession, describes the display properties and the module under which commands are evaluated. Multiple clients can share same such properties by using the same session_id. For example:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia> session_id = UUID(\"f03aec15-3e14-4d58-bcfa-82f8d33c9f9a\")\n\njulia> connect_repl(; session_id=session_id)","category":"page"},{"location":"howto/#Pass-a-command-non-interactively","page":"How To","title":"Pass a command non-interactively","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"To programmatically pass a command to the remote julia kernel use remotecmd. For example:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia> con2server = connect_remote(Sockets.localhost, 9093) # connect to port 9093 in localhost\n\njulia> remotecmd(con2server, \"myvar = 1\") # define a new var","category":"page"},{"location":"howto/#Use-alternatives-to-SSH","page":"How To","title":"Use alternatives to SSH","text":"","category":"section"},{"location":"howto/#AWS-Session-Manager","page":"How To","title":"AWS Session Manager","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"You can use AWS Session Manager instead of SSH to connect to remote hosts. To do this, first setup Session Manager for the EC2 instances you like. See the docs. Thereafter, install AWS CLI version 2 and then install the Session Manager plugin for AWS CLI on your local system.","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"Setup your AWS CLI by running aws configure on the command line. You can then connect to the RemoteREPL server on your EC2 instance with connect_repl(\"your-instance-id\"; tunnel=:aws, region=\"your-instance-region\"). The region argument is only required if the EC2 instance is not in the default region that your CLI was setup with.","category":"page"},{"location":"howto/#Kubernetes-kubectl","page":"How To","title":"Kubernetes kubectl","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"If kubectl is configured on your local system, you can use that to connect to RemoteREPL servers on your Kubernetes cluster. Run the following snippet: connect_repl(\"your-pod-name\"; tunnel=:k8s, namespace=\"your-namespace\"). The namespace argument is only required if the Pod is not in the default Kubernetes namespace.","category":"page"},{"location":"howto/#Use-in-Jupyter-or-Pluto","page":"How To","title":"Use in Jupyter or Pluto","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"In environments without any REPL integrations like Jupyter or Pluto notebooks you can use","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"connect_remote();","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"which will allow you to use @remote without the REPL mode.","category":"page"},{"location":"howto/#More-on-Pluto","page":"How To","title":"More on Pluto","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"Pluto presents a peculiarity as the default module is constantly changing. In order to closely track the newest notebook state, you will need to tap into the client's session and update the module. You could write the following code in the pluto notebook that updates the module every second (if you have a better event-driven update solution, please raise an issue!).","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"using PlutoLinks\n\nusing RemoteREPL, Sockets, UUIDs\n\nserver = Sockets.listen(Sockets.localhost, 27765)\n\n@async serve_repl(server)\n\nsession_id = UUID(\"f03aec15-3e14-4d58-bcfa-82f8d33c9f9a\")\n\ncon2server = connect_remote(Sockets.localhost, 27765; session_id=session_id)\n\n# update module in RemoteREPL when it changes in Pluto\n@use_task([]) do\n   mod = :nothing_yet\n   while true\n      newval = Symbol(\"workspace#\", Main.PlutoRunner.moduleworkspace_count[])\n      if newval != mod\n         mod = newval\n         remote_module!(Core.eval(Main, mod))\n      end\n      \n      sleep(0.05)\n   end\nend","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"Then open a repl and do:","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"julia> using RemoteREPL, Sockets, UUIDs\n\njulia> connect_repl(Sockets.localhost, 27765; session_id=UUID(\"f03aec15-3e14-4d58-bcfa-82f8d33c9f9a\"))","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"Since the session's module is being regularly updated by the Pluto notebook, your REPL will be in sync with the notebook's state.","category":"page"},{"location":"howto/#Troubleshooting-connection-issues","page":"How To","title":"Troubleshooting connection issues","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"Sometimes errors will be encountered. This section aims to show some errors experienced by users, and what the underlying problem was. We will use some terms in this section, introduced in the table below.","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"Term Explanation\n\"local REPL\" a REPL running on the same computer as the host. This could mean connecting two julia instances running on the same computer.\n\"remote REPL\" a REPL running on a different computer than the host.\n\"address\" a placeholder for the address you connect to, typically an IP-address. Examples of what an actual address could look like include \"pi@192.168.4.2\" and \"youruser@example.com\".","category":"page"},{"location":"howto/#Error:-IOError:-connect:-connection-refused-(ECONNREFUSED)","page":"How To","title":"Error: IOError: connect: connection refused (ECONNREFUSED)","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"This error has been encountered when","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"Running connect_repl() or connect_remote(), while attempting to connect to a local REPL. The problem was that no local REPL had previously run serve_repl(). To fix this, run serve_repl() in the local REPL.\nRunning connect_remote(), while attempting to connect to a remote REPL. The problem was that no address was provided. To fix this, pass an address as a string to connect_remote, as in connect_remote(\"address\")","category":"page"},{"location":"howto/#Error:-RemoteREPL-stream-was-closed-while-reading-header","page":"How To","title":"Error: RemoteREPL stream was closed while reading header","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"This error has been encountered when running connect_remote(\"address\") or connect_repl(\"address\"), while attempting to connect to a remote REPL. The problem was that the remote REPL had not previously run serve_repl(). To fix this, run serve_repl() in the remote REPL.","category":"page"},{"location":"howto/#Error:-Bad-owner-or-permissions-on-/home/username/.ssh/config","page":"How To","title":"Error: Bad owner or permissions on /home/username/.ssh/config","text":"","category":"section"},{"location":"howto/","page":"How To","title":"How To","text":"This error is raised by this line of code, from OpenSSH.  The requirements translates to that \"the config file must be owned by root or by the user running the ssh and can not be writable by any group or other users.\"  (Quoted from this thread). The fix is therefore to remove write permissions for  any group or other users. On a linux system, this is accomplished by running the following code.","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"chmod go-w /home/username/.ssh/*","category":"page"},{"location":"howto/","page":"How To","title":"How To","text":"If you are using a different operating system, please google how to remove write permissions on files, and try to do the same thing.","category":"page"},{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/#REPL-wire-protocol","page":"Design","title":"REPL wire protocol","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Currently RemoteREPL uses the standard Serialization library to format messages on the wire because this is simple to use.  However, this is not bidirectionally compatible between Julia versions so we'll probably move to a different message container format in the future.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"RemoteREPL formats results as text (using show(io, \"text/plain\", result)) for communication back to the client. This is helpful because:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The result of a computation might be large, and it should be summarized before sending back. show is an excellent tool for this.\nThe remote machine may be a separate application with different modules loaded; it may not be possible to deserialize the results in the local Julia session when custom types are involved.","category":"page"},{"location":"design/#The-standard-streams","page":"Design","title":"The standard streams","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"RemoteREPL doesn't interact with the standard streams stdout,stderr and stdin on the server. This avoids unexpected side effects such as interfereing with the server's normal logging and clashing with any concurrent RemoteREPL sessions.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"However this means that RemoteREPL misses out on some behavior you'd expect from the normal REPL:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Functions like println() have side effects on the server which are not visible on the client. See the howto for how @remote(stdout) helps with this.\nInteractive utilities like Cthulhu.jl — which reads from stdin and writes to stdout — don't work.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"In future I hope to improve this situation with better stream forwarding utilities.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#REPL-syntax","page":"Reference","title":"REPL syntax","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"RemoteREPL syntax is just normal Julia REPL syntax, the only minor difference is that ?expr produces help for expr, but we don't have a separate help mode for this.","category":"page"},{"location":"reference/#Security-considerations","page":"Reference","title":"Security considerations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Note that any logged-in users on the client or server machines can execute arbitrary commands in the serve_repl() process. For this reason, you should avoid using RemoteREPL on shared infrastructure like compute clusters if you don't trust other users on the system. (In the future perhaps we can avoid this by forwarding between socket files?)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"This package uses an SSH tunnel by default to forward traffic when host != Sockets.localhost, so it should be quite secure to use over an open network. If both client and server are on a secure network, it's possible to skip the tunnel to avoid setting up SSH. However, if anyone breaks into your network you'll be left with no security whatsoever.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"TLDR; this package aims to provide safe defaults for single-user machines. However, do not expose the RemoteREPL port to an open network. Abitrary remote code execution is the main feature provided by this package!","category":"page"},{"location":"reference/#Interrupting-remote-evaluation","page":"Reference","title":"Interrupting remote evaluation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"When the RemoteREPL client is waiting on a response, it will catch InterruptException and forward it to the server as an interruption message. This allows blocking operations such as IO to be interrupted safely.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"However, this doesn't work for non-yielding operations such as tight computational loops. For these cases, pressing Control-C three times will disconnect from the server, leaving the remote operation still running.","category":"page"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"connect_repl\nserve_repl\nconnect_remote\nRemoteREPL.@remote\nRemoteREPL.remote_eval\nRemoteREPL.remotecmd\nRemoteREPL.remote_module!","category":"page"},{"location":"reference/#RemoteREPL.connect_repl","page":"Reference","title":"RemoteREPL.connect_repl","text":"connect_repl([host=localhost,] port::Integer=27754;\n             tunnel = (host != localhost) ? :ssh : :none,\n             ssh_opts = ``, region=nothing, namespace=nothing,\n             repl=Base.active_repl, session_id = nothing)\n\nConnect client REPL to a remote host on port. This is then accessible as a remote sub-repl of the current Julia session.\n\nFor security, connect_repl() uses an ssh tunnel for remote hosts. This means that host needs to be running an ssh server and you need ssh credentials set up for use on that host. For secure networks this can be disabled by setting tunnel=:none.\n\nTo provide extra options to SSH, you may pass a Cmd object in the ssh_opts keyword, for example an identity file may be set with ssh_opts = `-i /path/to/identity.pem`. For a more permanent solution, add a Host section to your ssh config file.\n\nYou can also use the following technologies for tunneling in place of SSH:\n\nAWS Session Manager: set tunnel=:aws. The optional region keyword argument can be used to specify the AWS Region of your server.\nkubectl: set tunnel=:k8s. The optional namespace keyword argument can be used to specify the namespace of your Kubernetes resource.\n\nSee README.md for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RemoteREPL.serve_repl","page":"Reference","title":"RemoteREPL.serve_repl","text":"serve_repl([address=Sockets.localhost,] port=27754; [on_client_connect=nothing])\nserve_repl(server)\n\nStart a REPL server listening on interface address and port. In normal operation serve_repl() serves REPL clients indefinitely (ie., it does not return), so you will generally want to launch it using @async serve_repl() to do other useful work at the same time.\n\nThe hook on_client_connect may be supplied to modify the ServerSideSession for a client after each client connects. This can be used to define the default module in which the client evaluates commands.\n\nIf you want to be able to stop the server you can pass an already-listening server object (the result of Sockets.listen()). The server can then be cancelled from another task using close(server) as necessary to control the server lifetime.\n\nSecurity\n\nserve_repl() uses an unauthenticated, unecrypted protocol so it should not be used on open networks or multi-user machines where other users aren't trusted. For open networks, use the default address=Sockets.localhost and the automatic ssh tunnel support provided by the client-side connect_repl().\n\n\n\n\n\n","category":"function"},{"location":"reference/#RemoteREPL.connect_remote","page":"Reference","title":"RemoteREPL.connect_remote","text":"connect_remote([host=localhost,] port::Integer=27754;\n             tunnel = (host != localhost) ? :ssh : :none,\n             ssh_opts = ``, session_id = nothing)\n\nConnect to remote server without any REPL integrations. This will allow you to use @remote, but not the REPL mode. Useful in circumstances where no REPL is available, but interactivity is desired like Jupyter or Pluto notebooks. Otherwise, see connect_repl.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RemoteREPL.@remote","page":"Reference","title":"RemoteREPL.@remote","text":"@remote ex\n\nExecute expression ex on the other side of the current RemoteREPL connection and return the value.\n\nThis can be used in both directions:\n\nFrom the normal julia> prompt, execute ex on the remote server and return the value to the client.\nFrom a remote prompt, execute ex on the client and push the resulting value to the remote server.\n\nExamples\n\nPush a value from the client to the server:\n\njulia> client_val = 1:100;\n\njulia@localhost> server_val = @remote client_val\n1:100\n\nFetch a pair of variables (x,y) from the server, and plot them on the client with a single line:\n\n# In two lines\njulia> x,y = @remote (x, y)\n       plot(x, y)\n\n# Or as a single expression\njulia> plot(@remote((x, y))...)\n\n\n\n\n\n","category":"macro"},{"location":"reference/#RemoteREPL.remote_eval","page":"Reference","title":"RemoteREPL.remote_eval","text":"remote_eval(cmdstr)\nremote_eval(host, port, cmdstr)\n\nParse a string cmdstr, evaluate it in the remote REPL server's Main module or the session with session_id, then close the connection. Returns the result which the REPL would normally pass to show() (likely a Text object).\n\nFor example, to cause the remote Julia instance to exit, you could use\n\nusing RemoteREPL\nRemoteREPL.remote_eval(\"exit()\")\n\n\n\n\n\n","category":"function"},{"location":"reference/#RemoteREPL.remotecmd","page":"Reference","title":"RemoteREPL.remotecmd","text":"remotecmd(conn::Connection, out_stream::IO, cmdstr::String)\n\nEvaluate cmdstr in the remote session of connection conn and write result into out_stream. Also supports the magic RemoteREPL commands like %module and %include.\n\n\n\n\n\nremotecmd(cmdstr::String)\n\nEvaluate cmdstr in the last opened RemoteREPL connection and print result to Base.stdout\n\n\n\n\n\nremotecmd(conn::Connection, cmdstr::String)\n\nEvaluate cmdstr in the connection conn and print result to Base.stdout.\n\n\n\n\n\n","category":"function"},{"location":"reference/#RemoteREPL.remote_module!","page":"Reference","title":"RemoteREPL.remote_module!","text":"remote_module!(conn::Connection = _repl_client_connection, mod::Module)\n\nChange future remote commands in the session of connection conn to be evaluated into module mod. The default connection _repl_client_connection is the last established RemoteREPL connection. If the module cannot be evaluated locally pass the name as a string. Equivalent to using the %module magic.\n\n\n\n\n\nremote_module!(conn::Connection = _repl_client_connection, modstr::String)\n\nChange future remote commands in the session of connection conn to be evaluated into module identified by modstr. The default connection _repl_client_connection is the last established RemoteREPL connection. Equivalent to using the %module magic.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteREPL.jl","page":"Overview","title":"RemoteREPL.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"RemoteREPL allows you to connect your local julia REPL to a separate Julia process and run commands interactively:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Run code in the Main module of a remote Julia process\nStandard REPL tab completion and help mode with ?\nTransfer variables between processes with @remote\nAutomatic ssh tunnel for network security. Reconnects dropped connections.","category":"page"},{"location":"#Demo","page":"Overview","title":"Demo","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"(Image: asciicast)","category":"page"},{"location":"tutorial/#Connecting-two-Julia-processes","page":"Tutorial","title":"Connecting two Julia processes","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's connect two separate Julia processes on the same machine. First start up a REPL server in process A. This will allow any number of external clients to connect:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using RemoteREPL\n\njulia> @async serve_repl()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now start a separate Julia session B, connect to process A and execute some command:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using RemoteREPL\n\njulia> connect_repl();\nREPL mode remote_repl initialized. Press > to enter and backspace to exit.\n\njulia@localhost> x = 123\n123","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Back in the REPL of process A you'll now see that a client has connected, and the variable x has been set in the Main module:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"┌ Info: REPL client opened a connection\n└   peer = (ip\"127.0.0.1\", 0xa68e)\n\njulia> x\n123","category":"page"},{"location":"tutorial/#Transferring-variables","page":"Tutorial","title":"Transferring variables","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Normally RemoteREPL shows you a string-based summary of variables, but the actual Julia values are held in the remote process. Sometimes it's useful to transfer these to the client to make use of graphical utilities like plotting or other resources which you need a local copy of the object for. This can be done with the RemoteREPL @remote macro which executes an expression on the \"other side\" of the current remote connection.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Transfer the value from a variable x on the client to the variable y on the server:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> x = [1,2];\n\njulia@localhost> y = @remote(x)\n2-element Vector{Int64}:\n 1\n 2","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Transfer arrays x and y from the server and plot them on the client:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia@localhost> x = 1:42; y = x.^2;\n\njulia> a, b = @remote (x,y)\n       plot(a, b)","category":"page"}]
}
